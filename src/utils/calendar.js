const GOOGLE_CALENDAR_API_BASE = 'https://www.googleapis.com/calendar/v3';

export async function fetchCalendarEvents(token) {
    const minDate = new Date();
    minDate.setDate(minDate.getDate() - 21); // 3 weeks ago
    const timeMin = minDate.toISOString();

    const maxDate = new Date();
    maxDate.setDate(maxDate.getDate() + 21); // 3 weeks future
    const timeMax = maxDate.toISOString();

    const url = new URL(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events`);
    url.searchParams.append('timeMin', timeMin);
    url.searchParams.append('timeMax', timeMax);
    url.searchParams.append('singleEvents', 'true');
    url.searchParams.append('orderBy', 'startTime');

    const response = await fetch(url.toString(), {
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        }
    });

    if (!response.ok) {
        const errBody = await response.text();
        console.error('Calendar API Error Details:', errBody);
        throw new Error(`Failed to fetch events: ${response.statusText}. Details: ${errBody}`);
    }

    const data = await response.json();
    return data.items;
}

// Create a new event (Focus Time, Lunch, etc.)
export async function createEvent(token, { summary, description, startTime, endTime, colorId = '1' }) {
    const event = {
        summary,
        description,
        start: {
            dateTime: startTime,
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
        },
        end: {
            dateTime: endTime,
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone
        },
        colorId // e.g., '1' for lavender (usually focus), '5' for yellow (lunch)
    };

    const response = await fetch(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(event)
    });

    if (!response.ok) {
        throw new Error(`Failed to create event: ${response.statusText}`);
    }

    return response.json();
}

// Delete an event
export async function deleteEvent(token, eventId) {
    const response = await fetch(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events/${eventId}`, {
        method: 'DELETE',
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });

    if (!response.ok) {
        throw new Error(`Failed to delete event: ${response.statusText}`);
    }

    return true;
}

// Fetch exact week events and compute precise metadata insights on the fly
export async function fetchWeekInsights(token, offset) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Find the Sunday of the current week, then apply offset
    const currentDay = today.getDay();
    const startOfWeek = new Date(today);
    startOfWeek.setDate(today.getDate() - currentDay + (offset * 7));

    const endOfWeek = new Date(startOfWeek);
    endOfWeek.setDate(startOfWeek.getDate() + 7); // midnight of next Sunday

    const url = new URL(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events`);
    url.searchParams.append('timeMin', startOfWeek.toISOString());
    url.searchParams.append('timeMax', endOfWeek.toISOString());
    url.searchParams.append('singleEvents', 'true');
    url.searchParams.append('orderBy', 'startTime');

    const response = await fetch(url.toString(), {
        headers: {
            'Authorization': `Bearer ${token}`
        }
    });

    if (!response.ok) {
        throw new Error(`Failed to fetch week insights: ${response.statusText}`);
    }

    const data = await response.json();
    const events = data.items || [];

    // Tally based on advanced metadata rules
    const stats = {
        focusTimeHours: 0,
        meetingsHours: 0,
        oneOnOneHours: 0,
        recurrentHours: 0
    };

    for (const ev of events) {
        if (!ev.start || !ev.start.dateTime) continue;

        const start = new Date(ev.start.dateTime);
        const end = new Date(ev.end.dateTime);
        const durationHours = (end - start) / 3600000;

        // Skip declined
        const selfAttendee = ev.attendees ? ev.attendees.find(a => a.self) : null;
        if (selfAttendee && selfAttendee.responseStatus === 'declined') continue;

        const isCaiGenerated = (ev.description || '').includes('Generated by') && (ev.description || '').includes('Cai');
        const summary = (ev.summary || '').toLowerCase();

        // 1) Focus Time
        if ((isCaiGenerated && summary.includes('focus')) || summary.includes('focus time')) {
            stats.focusTimeHours += durationHours;
            continue;
        }

        // 2) Lunch / Breaks (Ignore in metrics)
        if (summary.includes('lunch') || summary.includes('coffee break') || summary.includes('break')) {
            continue;
        }

        // 3) Meetings Metadata
        const numAttendees = ev.attendees ? ev.attendees.length : 0;

        if (numAttendees > 1) {
            stats.meetingsHours += durationHours;

            // 1-on-1s
            if (numAttendees === 2) {
                stats.oneOnOneHours += durationHours;
            }

            // Recurrent Syncs
            if (ev.recurringEventId || ev.recurrence) {
                stats.recurrentHours += durationHours;
            }
        }
    }

    // Round everything precisely to 1 decimal place
    for (const k in stats) {
        stats[k] = Math.round(stats[k] * 10) / 10;
    }

    // Also get the goal from storage to return it
    const storageData = await new Promise(resolve => {
        chrome.storage.local.get(['caiPreferences'], resolve);
    });

    stats.focusTimeGoal = storageData.caiPreferences?.focusTimeGoal || 15;

    return stats;
}

// Simple Free/Busy analysis
export function findFreeSlots(events, workStartHour = 9, workEndHour = 17) {
    // Simplified for V0: This should ideally analyze days and find empty gaps 
    // between existing events during the work hours.
    // Full implementation requires mapping busy blocks and finding inverse areas.
    return [];
}
