import { runScheduler, clearAllCaiEvents, getLocalDateString, getWeekNumber, isThisWeek, isNextWeek, parseTimeString, findBestFit, removeSlotUsage, executeInBatches } from './scheduler';
import * as calendarUtils from './calendar';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';

describe('Scheduler Utils', () => {
    const mockToken = 'mock-oauth-token';

    beforeEach(() => {
        vi.spyOn(calendarUtils, 'fetchCalendarEvents').mockResolvedValue([]);
        vi.spyOn(calendarUtils, 'deleteEvent').mockResolvedValue(true);
        vi.spyOn(calendarUtils, 'createEvent').mockResolvedValue({ id: 'new-id' });
    });

    afterEach(() => {
        vi.resetAllMocks();
    });

    describe('clearAllCaiEvents', () => {
        it('deletes only Cai-generated events within the next 14 days', async () => {
            const today = new Date();
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);

            const pastDate = new Date(today);
            pastDate.setDate(today.getDate() - 2);

            calendarUtils.fetchCalendarEvents.mockResolvedValueOnce([
                { id: 'cai-tom', description: 'Generated by Cai', start: { dateTime: tomorrow.toISOString() } },
                { id: 'norm-tom', description: 'Normal text', start: { dateTime: tomorrow.toISOString() } },
                { id: 'cai-past', description: 'Generated by Cai', start: { dateTime: pastDate.toISOString() } }
            ]);

            const deleteCount = await clearAllCaiEvents(mockToken);
            expect(deleteCount).toBe(1);
            expect(calendarUtils.deleteEvent).toHaveBeenCalledTimes(1);
        });
    });

    describe('Helper Functions', () => {
        it('parseTimeString parses hours and mins correctly', () => {
            expect(parseTimeString('09:30')).toEqual([9, 30]);
        });

        it('executeInBatches processes array in chunks', async () => {
            const processor = vi.fn().mockResolvedValue('ok');
            const items = [1, 2, 3, 4];

            const results = await executeInBatches(items, processor, 2, 0); // 0 delay for test

            expect(processor).toHaveBeenCalledTimes(4);
            expect(results).toEqual(['ok', 'ok', 'ok', 'ok']);
        });
    });

    describe('runScheduler Integration', () => {
        it('bails out if no preferences provided', async () => {
            await runScheduler(mockToken, null);
            expect(calendarUtils.fetchCalendarEvents).not.toHaveBeenCalled();
        });

        it('schedules Lunch, Coffee, and Focus time properly', async () => {
            const prefs = {
                workingHoursStart: '09:00',
                workingHoursEnd: '17:00',
                lunchDuration: '60',
                lunchPreference: '12:00',
                coffeeBreakDuration: '15',
                focusTimeGoal: 2, // 2 hours
            };

            // Empty calendar, should schedule completely
            calendarUtils.fetchCalendarEvents.mockResolvedValueOnce([]);

            await runScheduler(mockToken, prefs);

            // 14 days evaluated. For each day we expect:
            // 1 Lunch Event
            // 1 Coffee Break Event
            // N Focus Time Events until 2 hours/week reached

            expect(calendarUtils.createEvent).toHaveBeenCalled();
            // We can assert the first call which should ideally be a lunch block for today
            const firstCall = calendarUtils.createEvent.mock.calls[0][1];
            expect(firstCall.summary).toContain('Lunch');
        });

        it('skips scheduling lunch if duration is 0', async () => {
            const prefs = {
                workingHoursStart: '09:00',
                workingHoursEnd: '17:00',
                lunchDuration: '0',
                lunchPreference: '12:00',
                coffeeBreakDuration: '0',
                focusTimeGoal: 1,
            };
            calendarUtils.fetchCalendarEvents.mockResolvedValueOnce([]);
            await runScheduler(mockToken, prefs);

            // Should only create Focus Time block, no lunches
            calendarUtils.createEvent.mock.calls.forEach(call => {
                expect(call[1].summary).not.toContain('Lunch');
            });
        });
    });
});
