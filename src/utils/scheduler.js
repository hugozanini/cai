import { fetchCalendarEvents, createEvent, deleteEvent } from './calendar.js';

/**
 * Main Scheduling Engine Algorithm
 * Follows local-first architecture. Runs primarily in Background Service Worker.
 */
export async function runScheduler(token, preferences) {
    console.log('Running Cai Scheduler with preferences:', preferences);

    if (!preferences) return;

    try {
        const rawEvents = await fetchCalendarEvents(token);

        // Process next 14 days
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // Group existing events by date string (YYYY-MM-DD)
        const eventsByDate = {};
        for (const ev of rawEvents) {
            if (!ev.start || !ev.start.dateTime) continue; // Skip all day events for now

            const startDate = new Date(ev.start.dateTime);
            const dateStr = getLocalDateString(startDate);

            if (!eventsByDate[dateStr]) eventsByDate[dateStr] = [];
            eventsByDate[dateStr].push({
                start: new Date(ev.start.dateTime),
                end: new Date(ev.end.dateTime),
                summary: ev.summary || 'Busy',
                description: ev.description || '',
                isCaiEvent: (ev.description || '').includes('Generated by') && (ev.description || '').includes('Cai')
            });
        }

        // Identify which weeks we are looking at (Current week and Next week)
        // We will keep a simple sum of scheduled focus time per week
        let currentWeekFocusSecs = 0;
        let nextWeekFocusSecs = 0;

        // First pass: count existing [Cai] Focus events to see how much we already have
        for (const dateStr in eventsByDate) {
            for (const ev of eventsByDate[dateStr]) {
                if (ev.isCaiEvent && ev.summary.includes('Focus Time')) {
                    const durationSecs = (ev.end - ev.start) / 1000;
                    if (isThisWeek(ev.start)) currentWeekFocusSecs += durationSecs;
                    else if (isNextWeek(ev.start)) nextWeekFocusSecs += durationSecs;
                }
            }
        }

        const focusGoalSecs = (preferences.focusTimeGoal || 10) * 3600;
        const newEvents = []; // Track newly generated events to include in insights immediately

        // Loop through the next 14 days
        for (let i = 0; i < 14; i++) {
            const targetDate = new Date(today);
            targetDate.setDate(targetDate.getDate() + i);

            // Skip weekends
            if (targetDate.getDay() === 0 || targetDate.getDay() === 6) continue;

            const dateStr = getLocalDateString(targetDate);
            const dayEvents = eventsByDate[dateStr] || [];

            // Determine working boundary times for this date
            const [wHourStart, wMinStart] = parseTimeString(preferences.workingHoursStart || '09:00');
            const [wHourEnd, wMinEnd] = parseTimeString(preferences.workingHoursEnd || '17:00');

            const workStart = new Date(targetDate);
            workStart.setHours(wHourStart, wMinStart, 0, 0);

            const workEnd = new Date(targetDate);
            workEnd.setHours(wHourEnd, wMinEnd, 0, 0);

            // Filter events strictly within working hours
            const busyBlocks = dayEvents
                .filter(e => e.start < workEnd && e.end > workStart)
                .map(e => ({
                    start: new Date(Math.max(e.start, workStart)),
                    end: new Date(Math.min(e.end, workEnd)),
                    summary: e.summary
                }))
                .sort((a, b) => a.start - b.start);

            // Consolidate overlapping blocks
            const consolidatedBusy = [];
            for (const block of busyBlocks) {
                if (consolidatedBusy.length === 0) {
                    consolidatedBusy.push(block);
                } else {
                    const last = consolidatedBusy[consolidatedBusy.length - 1];
                    if (block.start <= last.end) {
                        last.end = new Date(Math.max(last.end, block.end));
                    } else {
                        consolidatedBusy.push(block);
                    }
                }
            }

            // Find Free Slots
            const freeSlots = [];
            let cursor = new Date(workStart);

            for (const block of consolidatedBusy) {
                if (cursor < block.start) {
                    freeSlots.push({ start: cursor, end: block.start });
                }
                cursor = new Date(Math.max(cursor, block.end));
            }
            if (cursor < workEnd) {
                freeSlots.push({ start: cursor, end: workEnd });
            }

            // Has Lunch been scheduled?
            const hasLunch = dayEvents.some(e => e.summary.toLowerCase().includes('lunch'));
            if (!hasLunch && preferences.lunchDuration > 0) {
                const lunchMins = parseInt(preferences.lunchDuration);
                // Try to place near lunchPreference
                const [lHour, lMin] = parseTimeString(preferences.lunchPreference || '12:00');
                const preferredLunchTime = new Date(targetDate);
                preferredLunchTime.setHours(lHour, lMin, 0, 0);

                // Find a slot that can fit lunch around preferred time
                const lunchSlotDetails = findBestFit(freeSlots, lunchMins, preferredLunchTime);
                if (lunchSlotDetails) {
                    console.log('Scheduling Lunch for', dateStr);
                    await createEvent(token, {
                        summary: 'üçΩÔ∏è Lunch',
                        description: '<i>Generated by <b>Cai</b> ‚Äì your calendar intelligence.</i><br/><br/>Enjoy your meal and take a well-deserved break!',
                        startTime: lunchSlotDetails.start.toISOString(),
                        endTime: lunchSlotDetails.end.toISOString(),
                        colorId: '5' // Yellow
                    });

                    newEvents.push({
                        start: { dateTime: lunchSlotDetails.start.toISOString() },
                        end: { dateTime: lunchSlotDetails.end.toISOString() },
                        summary: 'üçΩÔ∏è Lunch',
                        description: 'Generated by Cai'
                    });

                    // Update free slots by cutting out the used chunk (simplified)
                    removeSlotUsage(freeSlots, lunchSlotDetails);
                }
            }

            // Has Coffee Break been scheduled?
            const hasCoffee = dayEvents.some(e => e.summary.includes('Coffee') || e.summary.includes('Break'));
            const coffeeMins = parseInt(preferences.coffeeBreakDuration || '0');
            if (!hasCoffee && coffeeMins > 0) {
                const preferredCoffeeTime = new Date(targetDate);
                preferredCoffeeTime.setHours(15, 0, 0, 0); // Default 3 PM

                const coffeeSlotDetails = findBestFit(freeSlots, coffeeMins, preferredCoffeeTime);
                if (coffeeSlotDetails) {
                    console.log('Scheduling Coffee Break for', dateStr);
                    await createEvent(token, {
                        summary: '‚òï Coffee Break',
                        description: '<i>Generated by <b>Cai</b> ‚Äì your calendar intelligence.</i><br/><br/>Take a moment to step away and recharge.',
                        startTime: coffeeSlotDetails.start.toISOString(),
                        endTime: coffeeSlotDetails.end.toISOString(),
                        colorId: '4' // Orange/Pink
                    });

                    newEvents.push({
                        start: { dateTime: coffeeSlotDetails.start.toISOString() },
                        end: { dateTime: coffeeSlotDetails.end.toISOString() },
                        summary: '‚òï Coffee Break',
                        description: 'Generated by Cai'
                    });

                    removeSlotUsage(freeSlots, coffeeSlotDetails);
                }
            }

            // Schedule Focus Time if needed
            const isCurrent = isThisWeek(targetDate);
            let neededSecs = isCurrent ? (focusGoalSecs - currentWeekFocusSecs) : (focusGoalSecs - nextWeekFocusSecs);

            if (neededSecs > 0) {
                // Try to schedule Focus Blocks of 60 mins max, 30 mins min
                for (const slot of freeSlots) {
                    let slotDurationSecs = (slot.end - slot.start) / 1000;

                    while (slotDurationSecs >= 1800 && neededSecs > 0) { // at least 30 mins
                        const focusBlockSecs = Math.min(3600, slotDurationSecs, neededSecs);

                        const focusStart = new Date(slot.start);
                        const focusEnd = new Date(focusStart.getTime() + (focusBlockSecs * 1000));

                        console.log('Scheduling Focus Time for', dateStr);
                        await createEvent(token, {
                            summary: 'üí° Focus Time',
                            description: '<i>Generated by <b>Cai</b> ‚Äì your calendar intelligence.</i><br/><br/>This block is protected for deep work. Silence your notifications and focus on what matters most.',
                            startTime: focusStart.toISOString(),
                            endTime: focusEnd.toISOString(),
                            colorId: '1' // Lavender
                        });

                        newEvents.push({
                            start: { dateTime: focusStart.toISOString() },
                            end: { dateTime: focusEnd.toISOString() },
                            summary: 'üí° Focus Time',
                            description: 'Generated by Cai'
                        });

                        slot.start = focusEnd;
                        slotDurationSecs = (slot.end - slot.start) / 1000;
                        neededSecs -= focusBlockSecs;

                        if (isCurrent) currentWeekFocusSecs += focusBlockSecs;
                        else nextWeekFocusSecs += focusBlockSecs;
                    }
                }
            }
        }

        console.log('Cai Scheduler completed pass.');

    } catch (err) {
        console.error('Error running scheduler:', err);
    }
}

export async function clearAllCaiEvents(token) {
    console.log('Clearing all Cai-generated events from today to 14 days in the future...');
    try {
        const rawEvents = await fetchCalendarEvents(token);

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const limitDate = new Date(today);
        limitDate.setDate(today.getDate() + 14);

        let deleteCount = 0;
        for (const ev of rawEvents) {
            if (!ev.start || !ev.start.dateTime) continue;

            const startDate = new Date(ev.start.dateTime);
            if (startDate < today || startDate > limitDate) continue;

            const isCaiEvent = (ev.description || '').includes('Generated by') && (ev.description || '').includes('Cai');

            if (isCaiEvent) {
                console.log(`Deleting Cai event: ${ev.summary} on ${startDate}`);
                await deleteEvent(token, ev.id);
                deleteCount++;
            }
        }

        console.log(`Successfully cleared ${deleteCount} Cai events.`);
        return deleteCount;
    } catch (err) {
        console.error('Error clearing events:', err);
        throw err;
    }
}

// Helpers
function getLocalDateString(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const d = String(date.getDate()).padStart(2, '0');
    return `${y}-${m}-${d}`;
}

function parseTimeString(timeStr) {
    return timeStr.split(':').map(Number);
}

function getWeekNumber(d) {
    // Absolute week number since Unix Epoch, starting on Sunday.
    const SUNDAY_OFFSET = 4 * 86400000;
    // Shift date to UTC to reliably ignore daylight savings when dividing by 7 days
    const utcDate = Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());
    return Math.floor((utcDate + SUNDAY_OFFSET) / 604800000);
}

function isThisWeek(date) {
    return getWeekNumber(date) === getWeekNumber(new Date());
}

function isNextWeek(date) {
    return getWeekNumber(date) === (getWeekNumber(new Date()) + 1);
}

function findBestFit(freeSlots, requiredMins, preferredTime) {
    const requiredMs = requiredMins * 60000;

    // Simple fit: find first slot that can hold it and is closest to preferredTime
    let bestFit = null;
    let minDiff = Infinity;

    for (const slot of freeSlots) {
        if ((slot.end - slot.start) >= requiredMs) {
            // Check diff against start of slot
            const diff1 = Math.abs(preferredTime - slot.start);
            // Or against preferred time inside slot
            let potentialStart = preferredTime;

            if (preferredTime < slot.start) potentialStart = slot.start;
            if (preferredTime > slot.end - requiredMs) potentialStart = new Date(slot.end - requiredMs);

            const diff2 = Math.abs(preferredTime - potentialStart);
            const actualDiff = Math.min(diff1, diff2);

            if (actualDiff < minDiff) {
                minDiff = actualDiff;
                bestFit = {
                    start: potentialStart,
                    end: new Date(potentialStart.getTime() + requiredMs)
                };
            }
        }
    }
    return bestFit;
}

function removeSlotUsage(slots, usedBlock) {
    // For simplicity array modification:
    for (let i = 0; i < slots.length; i++) {
        const slot = slots[i];
        if (usedBlock.start >= slot.start && usedBlock.end <= slot.end) {
            // Splitting slot
            const newSlot1 = { start: slot.start, end: usedBlock.start };
            const newSlot2 = { start: usedBlock.end, end: slot.end };

            slots.splice(i, 1); // remove original
            if (newSlot2.end > newSlot2.start) slots.splice(i, 0, newSlot2);
            if (newSlot1.end > newSlot1.start) slots.splice(i, 0, newSlot1);
            break;
        }
    }
}
