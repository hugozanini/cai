import { fetchCalendarEvents, createEvent, deleteEvent, fetchWeekInsights } from './calendar';
import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';

describe('Calendar Utils', () => {
    const mockToken = 'mock-oauth-token';
    const GOOGLE_CALENDAR_API_BASE = 'https://www.googleapis.com/calendar/v3';

    beforeEach(() => {
        global.fetch = vi.fn();
    });

    afterEach(() => {
        vi.resetAllMocks();
    });

    describe('fetchCalendarEvents', () => {
        it('fetches events from primary calendar with correct parameters', async () => {
            const mockEvents = [{ id: '1', summary: 'Test Event' }];
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ items: mockEvents })
            });

            const result = await fetchCalendarEvents(mockToken);

            expect(global.fetch).toHaveBeenCalledTimes(1);
            const callArgs = global.fetch.mock.calls[0];
            expect(callArgs[0]).toContain(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events`);
            expect(callArgs[0]).toContain('singleEvents=true');
            expect(callArgs[1].headers.Authorization).toBe(`Bearer ${mockToken}`);
            expect(result).toEqual(mockEvents);
        });

        it('throws an error if fetch fails', async () => {
            global.fetch.mockResolvedValueOnce({
                ok: false,
                statusText: 'Forbidden',
                text: async () => 'Rate Limit Exceeded'
            });

            await expect(fetchCalendarEvents(mockToken)).rejects.toThrow('Failed to fetch events: Forbidden');
        });
    });

    describe('createEvent', () => {
        it('creates an event successfully', async () => {
            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ id: 'new-id' })
            });

            const eventData = {
                summary: 'ðŸ’¡ Focus Time',
                description: 'Generated by Cai',
                startTime: '2026-02-22T10:00:00Z',
                endTime: '2026-02-22T11:00:00Z',
                colorId: '1'
            };

            const result = await createEvent(mockToken, eventData);

            expect(global.fetch).toHaveBeenCalledTimes(1);
            const callArgs = global.fetch.mock.calls[0];
            expect(callArgs[0]).toBe(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events`);
            expect(callArgs[1].method).toBe('POST');
            expect(callArgs[1].headers.Authorization).toBe(`Bearer ${mockToken}`);

            const reqBody = JSON.parse(callArgs[1].body);
            expect(reqBody.summary).toBe('ðŸ’¡ Focus Time');
            expect(reqBody.description).toBe('Generated by Cai');
            expect(reqBody.start.dateTime).toBe(eventData.startTime);
            expect(reqBody.end.dateTime).toBe(eventData.endTime);
            expect(reqBody.colorId).toBe('1');
            expect(result).toEqual({ id: 'new-id' });
        });

        it('throws error when creation fails', async () => {
            global.fetch.mockResolvedValueOnce({
                ok: false,
                statusText: 'Bad Request'
            });

            await expect(createEvent(mockToken, {})).rejects.toThrow('Failed to create event: Bad Request');
        });
    });

    describe('deleteEvent', () => {
        it('deletes an event successfully', async () => {
            global.fetch.mockResolvedValueOnce({
                ok: true
            });

            const result = await deleteEvent(mockToken, 'event-id-123');

            expect(global.fetch).toHaveBeenCalledTimes(1);
            const callArgs = global.fetch.mock.calls[0];
            expect(callArgs[0]).toBe(`${GOOGLE_CALENDAR_API_BASE}/calendars/primary/events/event-id-123`);
            expect(callArgs[1].method).toBe('DELETE');
            expect(callArgs[1].headers.Authorization).toBe(`Bearer ${mockToken}`);
            expect(result).toBe(true);
        });

        it('throws error when deletion fails', async () => {
            global.fetch.mockResolvedValueOnce({
                ok: false,
                statusText: 'Not Found'
            });

            await expect(deleteEvent(mockToken, 'bad-id')).rejects.toThrow('Failed to delete event: Not Found');
        });
    });

    describe('fetchWeekInsights', () => {
        it('computes insights accurately with varied metadata', async () => {
            const mockEvents = [
                // 1) Focus Time (1 hour)
                {
                    summary: 'Focus Time',
                    description: 'Generated by Cai',
                    start: { dateTime: '2026-02-23T10:00:00Z' },
                    end: { dateTime: '2026-02-23T11:00:00Z' },
                },
                // 2) Lunch break - Should be ignored
                {
                    summary: 'Lunch',
                    start: { dateTime: '2026-02-23T12:00:00Z' },
                    end: { dateTime: '2026-02-23T13:00:00Z' },
                },
                // 3) 1-on-1 (2 attendees, 1 hour)
                {
                    summary: '1:1 Sync',
                    start: { dateTime: '2026-02-24T14:00:00Z' },
                    end: { dateTime: '2026-02-24T15:00:00Z' },
                    attendees: [{ email: 'me@test.com', self: true, responseStatus: 'accepted' }, { email: 'peer@test.com' }]
                },
                // 4) Recurrent Sync (>2 attendees, Recurrent, 0.5 hours)
                {
                    summary: 'Daily Standup',
                    start: { dateTime: '2026-02-25T09:00:00Z' },
                    end: { dateTime: '2026-02-25T09:30:00Z' },
                    recurringEventId: 'recurrent-id-xyz',
                    attendees: [{ email: 'me' }, { email: 'p2' }, { email: 'p3' }]
                },
                // 5) Declined Meeting (Should be ignored entirely)
                {
                    summary: 'Town Hall',
                    start: { dateTime: '2026-02-25T11:00:00Z' },
                    end: { dateTime: '2026-02-25T12:00:00Z' },
                    attendees: [{ self: true, responseStatus: 'declined' }, { email: 'host' }, { email: 'p3' }]
                }
            ];

            global.fetch.mockResolvedValueOnce({
                ok: true,
                json: async () => ({ items: mockEvents })
            });

            // Mock chrome storage return value
            chrome.storage.local.get.mockImplementation((keys, callback) => {
                callback({ caiPreferences: { focusTimeGoal: 10 } });
            });

            const result = await fetchWeekInsights(mockToken, 0);

            // We expect:
            // Focus Time: 1 hour
            // Meetings total: 1-on-1 (1h) + Recurrent Sync (0.5h) = 1.5 hours. (Declined is ignored)
            // 1-on-1s: 1 hour
            // Recurrent: 0.5 hours

            expect(result).toEqual({
                focusTimeHours: 1,
                meetingsHours: 1.5,
                oneOnOneHours: 1,
                recurrentHours: 0.5,
                focusTimeGoal: 10
            });
        });
    });
});
